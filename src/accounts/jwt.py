"""The JWT module."""

import typing as t
from datetime import datetime

import jwt
import structlog
from django.conf import settings
from django.db import transaction
from jwt.exceptions import ExpiredSignatureError, InvalidTokenError
from ninja.errors import HttpError
from ninja_extra.exceptions import AuthenticationFailed
from ninja_jwt.token_blacklist.models import BlacklistedToken, OutstandingToken
from ninja_jwt.utils import datetime_from_epoch
from pydantic import UUID4, BaseModel, ConfigDict, TypeAdapter, field_serializer

logger = structlog.get_logger(__file__)


class _BaseJWTPayload(BaseModel):
    """The base JWT payload."""

    model_config = ConfigDict(use_enum_values=True, populate_by_name=True)

    iss: str
    aud: str
    sub: str
    exp: datetime
    iat: datetime
    email: str

    @field_serializer("exp")
    def serialize_exp(self, value: datetime) -> int:
        return int(value.timestamp())

    @field_serializer("iat")
    def serialize_iat(self, value: datetime) -> int:
        return int(value.timestamp())


class TOTPJWTPayload(_BaseJWTPayload):
    iss: t.Literal["https://api.letsrevel.io/"] = "https://api.letsrevel.io/"
    jti: str
    user_id: UUID4
    type: t.Literal["totp-access"] = "totp-access"


class ImpersonationRequestPayload(BaseModel):
    """Payload for impersonation request tokens.

    These short-lived tokens are generated by the admin panel and
    exchanged for an access token via the API.
    """

    model_config = ConfigDict(use_enum_values=True, populate_by_name=True)

    iss: t.Literal["https://api.letsrevel.io/"] = "https://api.letsrevel.io/"
    aud: str
    jti: str
    exp: datetime
    iat: datetime
    type: t.Literal["impersonation-request"] = "impersonation-request"
    admin_user_id: UUID4
    target_user_id: UUID4


def validate_otp_jwt(
    token: str,
    key: str | None = None,
    audience: str | None = None,
    algorithms: list[str] | None = None,
) -> TOTPJWTPayload:
    """Verify and parse the JWT token.

    Args:
        token (str): The JWT token.
        key (str): The secret key.
        audience (str): The audience.
        algorithms (list): The algorithms.

    Returns:
        JWTPayload: The decoded JWT payload.

    Raises:
        AuthenticationFailed: If token verification fails.
    """
    key = key or settings.SECRET_KEY
    audience = audience or settings.JWT_AUDIENCE
    algorithms = algorithms or [settings.JWT_ALGORITHM]
    try:
        decoded_jwt = jwt.decode(
            token,
            key=key,
            audience=audience,
            algorithms=algorithms,
        )
        return TypeAdapter(TOTPJWTPayload).validate_python(decoded_jwt)
    except ExpiredSignatureError as e:
        logger.debug("token_has_expired")
        raise AuthenticationFailed("Token has expired.") from e
    except InvalidTokenError as e:
        logger.debug("invalid_token")
        raise AuthenticationFailed("Invalid token.") from e
    except Exception as e:
        logger.debug("authentication_failed", exc_info=str(e))
        raise AuthenticationFailed("Authentication failed.") from e


def create_token(payload: dict[str, t.Any], secret: str, algorithm: str) -> str:
    """Helper function to create a JWT token.

    Args:
        payload (dict): The payload.
        secret (str): The secret key.
        algorithm (str): The algorithm.

    Returns:
        str: The JWT token.
    """
    return jwt.encode(payload, secret, algorithm=algorithm)


def check_blacklist(jti: str) -> None:
    """Checks if this token is present in the token blacklist.  Raises `HttpError` if so."""
    if BlacklistedToken.objects.filter(token__jti=jti).exists():
        raise HttpError(401, "Token is blacklisted.")


@transaction.atomic
def blacklist(
    token: str,
    key: str | None = None,
    audience: str | None = None,
    algorithms: list[str] | None = None,
) -> BlacklistedToken:
    """Ensures this token is included in the outstanding token list and adds it to the blacklist."""
    key = key or settings.SECRET_KEY
    audience = audience or settings.JWT_AUDIENCE
    algorithms = algorithms or [settings.JWT_ALGORITHM]
    payload = jwt.decode(token, key=key, audience=audience, algorithms=algorithms, options={"verify_signature": False})
    jti = payload["jti"]
    exp = payload["exp"]

    # Ensure outstanding token exists with given jti
    token_db, _ = OutstandingToken.objects.get_or_create(
        jti=jti,
        defaults={
            "token": token,
            "expires_at": datetime_from_epoch(exp),
        },
    )

    return BlacklistedToken.objects.get_or_create(token=token_db)[0]


def create_impersonation_request_token(
    admin_user_id: str,
    target_user_id: str,
    jti: str,
) -> str:
    """Create a short-lived impersonation request token.

    Args:
        admin_user_id: UUID of the admin performing impersonation.
        target_user_id: UUID of the user to be impersonated.
        jti: Unique JWT ID for tracking and single-use enforcement.

    Returns:
        Signed JWT token string.
    """
    from django.utils import timezone

    now = timezone.now()
    payload = {
        "iss": "https://api.letsrevel.io/",
        "aud": settings.JWT_AUDIENCE,
        "jti": jti,
        "exp": int((now + settings.IMPERSONATION_REQUEST_TOKEN_LIFETIME).timestamp()),
        "iat": int(now.timestamp()),
        "type": "impersonation-request",
        "admin_user_id": admin_user_id,
        "target_user_id": target_user_id,
    }
    return create_token(payload, settings.SECRET_KEY, settings.JWT_ALGORITHM)


def validate_impersonation_request_token(
    token: str,
    key: str | None = None,
    audience: str | None = None,
    algorithms: list[str] | None = None,
) -> ImpersonationRequestPayload:
    """Validate and parse an impersonation request token.

    Args:
        token: The JWT token string.
        key: Optional secret key (defaults to settings.SECRET_KEY).
        audience: Optional audience (defaults to settings.JWT_AUDIENCE).
        algorithms: Optional list of algorithms (defaults to [settings.JWT_ALGORITHM]).

    Returns:
        Validated ImpersonationRequestPayload.

    Raises:
        AuthenticationFailed: If token verification fails.
    """
    key = key or settings.SECRET_KEY
    audience = audience or settings.JWT_AUDIENCE
    algorithms = algorithms or [settings.JWT_ALGORITHM]
    try:
        decoded_jwt = jwt.decode(
            token,
            key=key,
            audience=audience,
            algorithms=algorithms,
        )
        # Verify token type
        if decoded_jwt.get("type") != "impersonation-request":
            raise AuthenticationFailed("Invalid token type.")
        return TypeAdapter(ImpersonationRequestPayload).validate_python(decoded_jwt)
    except AuthenticationFailed:
        # Re-raise our own exceptions without wrapping
        raise
    except ExpiredSignatureError as e:
        logger.debug("impersonation_token_expired")
        raise AuthenticationFailed("Impersonation token has expired.") from e
    except InvalidTokenError as e:
        logger.debug("invalid_impersonation_token")
        raise AuthenticationFailed("Invalid impersonation token.") from e
    except Exception as e:
        logger.debug("impersonation_auth_failed", exc_info=str(e))
        raise AuthenticationFailed("Impersonation authentication failed.") from e


def create_impersonation_access_token(
    user: t.Any,
    admin_user: t.Any,
    impersonation_log_id: str,
) -> str:
    """Create an access token for an impersonated session.

    This token includes all standard user claims plus impersonation metadata.
    Uses RefreshToken.for_user to ensure compatibility with the rest of the app.
    No refresh token is issued for impersonation sessions.

    Args:
        user: The RevelUser being impersonated.
        admin_user: The admin performing the impersonation.
        impersonation_log_id: UUID of the ImpersonationLog for audit trail.

    Returns:
        Signed JWT access token string.
    """
    from ninja_jwt.tokens import RefreshToken

    from accounts import schema

    # Use RefreshToken.for_user to create a properly structured token
    token = RefreshToken.for_user(user)

    # Add standard user claims (same as get_token_pair_for_user)
    token.payload.update(schema.RevelUserSchema.from_orm(user).model_dump(mode="json"))
    token.payload.update(
        {
            "sub": str(user.id),
            "groups": list(user.groups.values_list("name", flat=True)),
            "is_staff": user.is_staff,
            "is_superuser": user.is_superuser,
        }
    )

    # Add impersonation-specific claims
    token.payload.update(
        {
            "is_impersonated": True,
            "impersonated_by_id": str(admin_user.id),
            "impersonated_by_email": admin_user.email,
            "impersonated_by_name": admin_user.display_name,
            "impersonation_log_id": impersonation_log_id,
        }
    )

    # Get access token with custom lifetime for impersonation
    access_token = token.access_token  # type: ignore[attr-defined]
    access_token.set_exp(lifetime=settings.IMPERSONATION_ACCESS_TOKEN_LIFETIME)

    return str(access_token)
